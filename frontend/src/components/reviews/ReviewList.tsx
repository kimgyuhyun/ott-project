"use client";
import { useState, useEffect, useRef } from "react";
import { getAnimeReviews, createReview, toggleReviewLike, updateReview, deleteReview, isValidReviewResponse } from "@/lib/api/reviews";
import { createOrUpdateRating, getMyRating, getRatingStats } from "@/lib/api/rating";
import Star from "@/components/ui/Star";
import { getCurrentUser } from "@/lib/api/auth";
import CommentList from "./CommentList";

interface Review {
  id: number;
  userName: string;
  userProfileImage?: string;
  content: string;
  rating: number;
  likeCount: number;
  isLikedByCurrentUser: boolean;
  createdAt?: string;
  updatedAt?: string;
}

interface ReviewListProps {
  animeId: number;
}

export default function ReviewList({ animeId }: ReviewListProps) {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [currentUser, setCurrentUser] = useState<any>(null);
  const [editingReview, setEditingReview] = useState<Review | null>(null);
  const [newReview, setNewReview] = useState({ content: '' });
  const [sortBy, setSortBy] = useState('latest');
  const [expandedReviews, setExpandedReviews] = useState<Set<number>>(new Set());
  const [myRating, setMyRating] = useState<number | null>(null);
  const [showLoginRequired, setShowLoginRequired] = useState(false);
  const halfKeys = ['1.0','1.5','2.0','2.5','3.0','3.5','4.0','4.5','5.0'] as const;
  const [ratingStats, setRatingStats] = useState<Record<string, number>>({ '1.0':0,'1.5':0,'2.0':0,'2.5':0,'3.0':0,'3.5':0,'4.0':0,'4.5':0,'5.0':0 });
  const [hoverRating, setHoverRating] = useState<number | null>(null);
  const [averageFromApi, setAverageFromApi] = useState<number>(0);
  const [ratingLoading, setRatingLoading] = useState(false);
  const [ratingError, setRatingError] = useState<string | null>(null);
  const scrollYRef = useRef<number>(0);

  useEffect(() => {
    loadReviews();
    loadCurrentUser();
    loadRatings();
  }, [animeId, sortBy]);
  // animeId Î≥ÄÍ≤Ω Ïãú Î≥ÑÏ†ê ÌÜµÍ≥Ñ Ìï≠ÏÉÅ Î°úÎìú
  useEffect(() => {
    console.log('üîÑ loadRatings triggered by animeId change:', animeId);
    loadRatings();
  }, [animeId]);

  // Ï¥àÍ∏∞ ÎßàÏö¥Ìä∏ Ïãú Ïä§ÌÅ¨Î°§ Î≥µÏõê
  useEffect(() => {
    restoreScroll();
  }, []);

  const saveScroll = () => {
    if (typeof window !== 'undefined') {
      scrollYRef.current = window.scrollY;
    }
  };

  const restoreScroll = () => {
    if (typeof window !== 'undefined') {
      window.scrollTo({ top: scrollYRef.current, behavior: 'instant' as ScrollBehavior });
    }
  };

  const loadRatings = async () => {
    try {
      console.log('‚ñ∂Ô∏è loadRatings start for animeId=', animeId);
      setRatingLoading(true);
      setRatingError(null);
      const [stats, mine] = await Promise.all([
        getRatingStats(animeId).catch(() => ({ distribution: { '1.0':0,'1.5':0,'2.0':0,'2.5':0,'3.0':0,'3.5':0,'4.0':0,'4.5':0,'5.0':0 }, average: 0 })),
        getMyRating(animeId).catch(() => null),
      ]);
      const distRaw = (stats as any)?.distribution || {};
      const dist: Record<string, number> = { '1.0':0,'1.5':0,'2.0':0,'2.5':0,'3.0':0,'3.5':0,'4.0':0,'4.5':0,'5.0':0 };
      Object.keys(distRaw).forEach(k => {
        const key = String(k);
        if (halfKeys.includes(key as any)) {
          const v = (distRaw as any)[k];
          dist[key] = typeof v === 'number' ? v : Number(v) || 0;
        }
      });
      const avg = (stats as any)?.average;
      setRatingStats(dist);
      setAverageFromApi(typeof avg === 'number' ? avg : 0);
      if (typeof mine === 'number' && mine > 0) setMyRating(mine as number);
      const values = halfKeys.map(k => dist[k]);
      const totalFromDist = values.reduce((a,b)=>a+b,0);
      const maxCount = Math.max(...values, 0);
      const pcts = halfKeys.map(s => {
        const c = dist[s] ?? 0;
        return maxCount > 0 ? Math.round((c / maxCount) * 100) : 0;
      });
      console.log('‚úÖ loadRatings done: dist=', dist, 'avg=', avg, 'mine=', mine, 'maxCount=', maxCount, 'totalFromDist=', totalFromDist, 'pcts=', pcts);
    } catch (e) {
      console.log('ÌèâÏ†ê Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:', e);
      setRatingError('Î∂ÑÌè¨Î•º Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    } finally { setRatingLoading(false); }
  };

  const loadCurrentUser = async () => {
    try {
      const user = await getCurrentUser();
      setCurrentUser(user);
    } catch (error) {
      console.log('ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:', error);
    }
  };

  const loadReviews = async () => {
    try {
      setIsLoading(true);
      saveScroll();
      console.log('üîç Î¶¨Î∑∞ Î°úÎìú ÏãúÏûë - animeId:', animeId, 'sortBy:', sortBy);
      
      const data = await getAnimeReviews(animeId, sortBy);
      console.log('üì° API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞:', data);
      console.log('üìä Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ:', typeof data);
      console.log('üîë Îç∞Ïù¥ÌÑ∞ ÌÇ§Îì§:', data ? Object.keys(data) : 'null');
      
      // Î∞±ÏóîÎìú ÏùëÎãµ Íµ¨Ï°∞Ïóê ÎßûÏ∂∞ Ï†ïÌôïÌûà ÌååÏã±
      let reviewsData: Review[] = [];
      
      if (data && typeof data === 'object') {
        if ('content' in data && Array.isArray(data.content)) {
          console.log('‚úÖ PagedResponse Íµ¨Ï°∞Î°ú ÌååÏã±Îê®');
          reviewsData = data.content;
        } else if ('items' in data && Array.isArray(data.items)) {
          console.log('‚úÖ Items Íµ¨Ï°∞Î°ú ÌååÏã±Îê®');
          reviewsData = data.items;
        } else if (Array.isArray(data)) {
          console.log('‚úÖ ÏßÅÏ†ë Î∞∞Ïó¥Î°ú ÌååÏã±Îê®');
          reviewsData = data;
        } else {
          console.warn('‚ö†Ô∏è ÏòàÏÉÅÏπò Î™ªÌïú Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞:', data);
          reviewsData = [];
        }
      } else {
        console.warn('‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞Í∞Ä nullÏù¥Í±∞ÎÇò undefined');
        reviewsData = [];
      }
      
      console.log('üéØ ÏµúÏ¢Ö ÌååÏã±Îêú Î¶¨Î∑∞ Îç∞Ïù¥ÌÑ∞:', reviewsData);
      console.log('üìù Î¶¨Î∑∞ Í∞úÏàò:', reviewsData.length);
      
      setReviews(reviewsData);
      
      // ÏÇ¨Ïö©Ïûê ÌèâÏ†êÏùÄ Rating APIÏóêÏÑú Î°úÎìúÌï®
      
    } catch (error) {
      console.error('‚ùå Î¶¨Î∑∞ Î°úÎìú Ïã§Ìå®:', error);
      setReviews([]);
    } finally {
      setIsLoading(false);
      // Îç∞Ïù¥ÌÑ∞ Î∞òÏòÅ ÌõÑ Ïä§ÌÅ¨Î°§ Î≥µÏõê
      setTimeout(() => restoreScroll(), 0);
    }
  };

  // ÌèâÏ†ê Î∂ÑÌè¨ Í≥ÑÏÇ∞
  const getRatingDistribution = () => ratingStats;

  // ÌèâÍ∑† ÌèâÏ†ê Í≥ÑÏÇ∞
  const getAverageRating = () => (typeof averageFromApi === 'number' ? Math.round(averageFromApi * 10) / 10 : 0);

  // ÌèâÏ†ê ÌÖçÏä§Ìä∏ Î≥ÄÌôò
  const getRatingText = (rating: number) => {
    if (rating >= 4.5) return 'ÏµúÍ≥†ÏòàÏöî';
    if (rating >= 4.0) return 'Ïû¨ÎØ∏ÏûàÏñ¥Ïöî';
    if (rating >= 3.0) return 'Î≥ºÎßåÌï¥Ïöî';
    if (rating >= 2.0) return 'Í∑∏Îü≠Ï†ÄÎü≠';
    return 'Î≥ÑÎ°úÏòàÏöî';
  };

  const handleCreateReview = async () => {
    if (!currentUser) {
      setShowLoginRequired(true);
      setTimeout(() => setShowLoginRequired(false), 3000);
      return;
    }
    
    if (!newReview.content.trim()) return;
    
    try {
      await createReview(animeId, { content: newReview.content });
      setNewReview({ content: '' });
      await loadReviews();
    } catch (error) {
      console.error('Î¶¨Î∑∞ ÏûëÏÑ± Ïã§Ìå®:', error);
    }
  };

  const handleUpdateReview = async () => {
    if (!editingReview || !editingReview.content.trim()) return;
    
    saveScroll();
    const prev = reviews;
    const targetId = editingReview.id;
    const newContent = editingReview.content;

    setReviews(prevReviews =>
      prevReviews.map(r => (r.id === targetId ? { ...r, content: newContent } : r))
    );
    setEditingReview(null);

    try {
      await updateReview(animeId, targetId, { content: newContent });
      restoreScroll();
    } catch (error) {
      console.error('Î¶¨Î∑∞ ÏàòÏ†ï Ïã§Ìå®:', error);
      setReviews(prev);
      loadReviews();
      setTimeout(() => restoreScroll(), 0);
    }
  };

  const handleDeleteReview = async (reviewId: number) => {
    if (!confirm('Ï†ïÎßêÎ°ú Ïù¥ Î¶¨Î∑∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;
    
    saveScroll();
    const prev = reviews;
    setReviews(prevReviews => prevReviews.filter(r => r.id !== reviewId));

    try {
      await deleteReview(animeId, reviewId);
      restoreScroll();
    } catch (error) {
      console.error('Î¶¨Î∑∞ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      setReviews(prev);
      loadReviews();
      setTimeout(() => restoreScroll(), 0);
    }
  };

  const handleToggleLike = async (reviewId: number) => {
    if (!currentUser) {
      setShowLoginRequired(true);
      setTimeout(() => setShowLoginRequired(false), 3000);
      return;
    }
    
    saveScroll();
    const prev = reviews;
    // ÎÇôÍ¥ÄÏ†Å ÌÜ†Í∏Ä
    setReviews(prevReviews => prevReviews.map(r => {
      if (r.id !== reviewId) return r;
      const liked = !r.isLikedByCurrentUser;
      return {
        ...r,
        isLikedByCurrentUser: liked,
        likeCount: r.likeCount + (liked ? 1 : -1),
      };
    }));

    try {
      await toggleReviewLike(animeId, reviewId);
      // ÏÑ±Í≥µ Ïãú Ï∂îÍ∞Ä ÏûëÏóÖ ÏóÜÏùå
      restoreScroll();
    } catch (error) {
      console.error('Ï¢ãÏïÑÏöî ÌÜ†Í∏Ä Ïã§Ìå®:', error);
      setReviews(prev);
      setTimeout(() => restoreScroll(), 0);
    }
  };

  const toggleReviewExpansion = (reviewId: number) => {
    setExpandedReviews(prev => {
      const newSet = new Set(prev);
      if (newSet.has(reviewId)) {
        newSet.delete(reviewId);
      } else {
        newSet.add(reviewId);
      }
      return newSet;
    });
  };

  const handleRatingClick = async (rating: number) => {
    if (!currentUser) {
      setShowLoginRequired(true);
      setTimeout(() => setShowLoginRequired(false), 3000);
      return;
    }
    saveScroll();
    const prevMy = myRating;
    const prevStats = { ...ratingStats };

    // ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏: Î∂ÑÌè¨/ÎÇ¥ Î≥ÑÏ†ê
    // 0.5 Ïä§ÌÖù Ïú†ÏßÄ
    const halfStep = Math.max(0.5, Math.min(5, Math.round(rating * 2) / 2));
    setMyRating(halfStep); // Ï¶âÏãú UI Î∞òÏòÅ
    setRatingStats(curr => {
      const next: Record<string, number> = { ...curr };
      const prevKey = typeof prevMy === 'number' ? (Math.round(prevMy * 2) / 2).toFixed(1) : undefined;
      const newKey = (Math.round(halfStep * 2) / 2).toFixed(1);
      if (prevKey && next[prevKey] !== undefined) next[prevKey] = Math.max(0, (next[prevKey] || 0) - 1);
      if (next[newKey] !== undefined) next[newKey] = (next[newKey] || 0) + 1;
      return next;
    });

    try {
      // API Ìò∏Ï∂úÍ≥º ÎèôÍ∏∞Ìôî
      await createOrUpdateRating(animeId, halfStep);
      // ÏÑúÎ≤Ñ Í∏∞Ï§Ä Ïû¨Ï°∞Ìöå ÌõÑ myRatingÎèÑ Î≥¥Ï†ï
      await loadRatings();
      setMyRating(halfStep);
      restoreScroll();
    } catch (e) {
      console.error('Î≥ÑÏ†ê Ï†ÄÏû• Ïã§Ìå®:', e);
      setMyRating(prevMy);
      setRatingStats(prevStats);
      setTimeout(() => restoreScroll(), 0);
    }
  };

  const ratingDistribution = ratingStats; // Î¨∏ÏûêÏó¥ ÌÇ§ ('1.0'..'5.0' by 0.5)
  const averageRating = getAverageRating();
  const valuesForCalc = halfKeys.map(k => ratingDistribution[k] ?? 0);
  const totalFromDist = valuesForCalc.reduce((a,b)=>a+b,0);
  const totalRatings = totalFromDist;
  const maxCount = Math.max(...valuesForCalc, 0);
  const hasAny = valuesForCalc.some(v => v > 0);

  if (isLoading) {
    return <div className="text-center py-8">Î¶¨Î∑∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>;
  }

  return (
    <div className="space-y-6">
      {/* ÌèâÏ†ê Ï†ïÎ≥¥ ÏÑπÏÖò */}
      <div className="bg-white rounded-lg p-6 border border-gray-200">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 items-end">
          {/* ÎÇ¥ Î≥ÑÏ†ê */}
          <div className="text-center">
            <h3 className="text-lg font-semibold text-gray-800 mb-2">ÎÇ¥ Î≥ÑÏ†ê</h3>
            <div className="text-3xl font-bold text-purple-600 mb-1">{myRating ?? '-'}</div>
            <div className="text-sm text-gray-600 mb-3">{myRating ? getRatingText(myRating) : 'ÌèâÏ†ê ÏóÜÏùå'}</div>
            <div className="flex justify-center gap-3"
                 onMouseLeave={() => setHoverRating(null)}>
              {[1, 2, 3, 4, 5].map((index) => {
                const active = hoverRating ?? myRating ?? 0;
                const score = active || 0;
                const filled = score >= index ? 1 : Math.max(0, Math.min(1, score - (index - 1)));
                return (
                  <button
                    key={index}
                    onClick={(e) => {
                      const rect = (e.currentTarget as HTMLButtonElement).getBoundingClientRect();
                      const half = (e.clientX - rect.left) / rect.width <= 0.5 ? 0.5 : 1.0;
                      handleRatingClick(index - 1 + half);
                    }}
                    onMouseMove={(e) => {
                      const rect = (e.currentTarget as HTMLButtonElement).getBoundingClientRect();
                      const half = (e.clientX - rect.left) / rect.width <= 0.5 ? 0.5 : 1.0;
                      const next = index - 1 + half;
                      if (hoverRating !== next) setHoverRating(next);
                    }}
                    onMouseEnter={(e) => {
                      const rect = (e.currentTarget as HTMLButtonElement).getBoundingClientRect();
                      const half = (e.clientX - rect.left) / rect.width <= 0.5 ? 0.5 : 1.0;
                      setHoverRating(index - 1 + half);
                    }}
                    onKeyDown={(e) => {
                      if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        const next = Math.min(5, Math.round(((myRating || 0) + 0.5) * 2) / 2);
                        handleRatingClick(next);
                      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const prev = Math.max(0.5, Math.round(((myRating || 0) - 0.5) * 2) / 2);
                        handleRatingClick(prev);
                      }
                    }}
                    aria-label={`Î≥Ñ ${index}`}
                    className="w-7 h-7 inline-flex items-center justify-center cursor-pointer pointer-events-auto"
                  >
                    <Star value={filled} size={28} color="#8B5CF6" emptyColor="#E5E7EB" />
                  </button>
                );
              })}
            </div>
          </div>

          {/* ÌèâÍ∑† Î≥ÑÏ†ê */}
          <div className="text-center">
            <h3 className="text-lg font-semibold text-gray-800 mb-2">ÌèâÍ∑† Î≥ÑÏ†ê</h3>
            <div className="text-3xl font-bold text-purple-600 mb-1">{averageRating.toFixed(1)}</div>
            <div className="text-sm text-gray-600 mb-3">{totalRatings}Í∞úÏùò Î≥ÑÏ†ê</div>
            <div className="flex justify-center gap-2">
              {[1, 2, 3, 4, 5].map((index) => {
                const score = averageRating;
                const filled = score >= index ? 1 : Math.max(0, Math.min(1, score - (index - 1)));
                return (
                  <Star key={index} value={filled} size={28} color="#8B5CF6" emptyColor="#E5E7EB" />
                );
              })}
            </div>
          </div>

          {/* ÌèâÏ†ê Î∂ÑÌè¨ (ÏÑ∏Î°ú ÌûàÏä§ÌÜ†Í∑∏Îû®, Ï†ÑÏ≤¥ ÎåÄÎπÑ ÎπÑÏú®) */}
          {hasAny && (
            <div className="text-center">
              <h3 className="text-lg font-semibold text-gray-800 mb-4">ÌèâÏ†ê Î∂ÑÌè¨</h3>
              {(() => {
                const chartHeight = 140; // px
                const minBarPx = 4; // ÏãúÍ∞Å ÏµúÏÜå ÎÜíÏù¥
                return (
                  <div className="flex items-end justify-between px-3" style={{ height: chartHeight + 'px' }}>
                    {halfKeys.map((label) => {
                      const count = ratingDistribution[label] ?? 0;
                      const ratio = totalRatings > 0 ? (count / totalRatings) : 0;
                      let barPx = Math.round(ratio * chartHeight * 0.8); // ÏµúÎåÄ 80%
                      if (count > 0 && barPx < minBarPx) barPx = minBarPx;
                      const isIntegerLabel = label.endsWith('.0');
                      return (
                        <div key={label} className="flex flex-col items-center w-9" aria-label={`Î≥Ñ ${label}: ${count}Í∞ú (${Math.round(ratio*100)}%)`}>
                          <div className="flex items-end" style={{ height: chartHeight + 'px' }}>
                            <div className="w-3 rounded-t transition-[height] duration-150 hover:brightness-110" style={{ height: barPx + 'px', backgroundColor: '#8B5CF6' }} />
                          </div>
                          {isIntegerLabel ? (
                            <div className="text-xs text-gray-900 font-medium mt-1">{label}</div>
                          ) : (
                            <div className="text-xs mt-1" style={{ visibility: 'hidden' }}>.</div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                );
              })()}
            </div>
          )}
          {ratingLoading && (
            <div className="mt-2 px-3">
              <div className="grid grid-cols-5 gap-3">
                {[1,2,3,4,5].map(k => (
                  <div key={k} className="w-full h-3 rounded-full bg-gray-200 animate-pulse" />
                ))}
              </div>
            </div>
          )}
          {ratingError && (
            <div className="mt-2 text-center text-sm text-red-600">
              {ratingError}
              <button onClick={loadRatings} className="ml-2 px-2 py-0.5 bg-purple-600 text-white rounded">Ïû¨ÏãúÎèÑ</button>
            </div>
          )}
        </div>

        {/* Î¶¨Î∑∞ ÏûëÏÑ± - Ìï≠ÏÉÅ ÌëúÏãú */}
        <div className="mt-6">
          {!currentUser && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <p className="text-blue-800 text-sm">Î¶¨Î∑∞Î•º ÏûëÏÑ±ÌïòÎ†§Î©¥ Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.</p>
            </div>
          )}
          <textarea
            value={newReview.content}
            onChange={(e) => setNewReview(prev => ({ ...prev, content: e.target.value }))}
            placeholder="Ïù¥ ÏûëÌíàÏóê ÎåÄÌïú ÎÇ¥ ÌèâÍ∞ÄÎ•º ÎÇ®Í≤®Î≥¥ÏÑ∏Ïöî!"
            className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
            rows={4}
          />
          <div className="flex justify-end mt-3">
            <button
              onClick={handleCreateReview}
              disabled={!newReview.content.trim()}
              className="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              ÏûëÏÑ±ÌïòÍ∏∞
            </button>
          </div>
        </div>
      </div>

      {/* Ï†ïÎ†¨ ÏòµÏÖò (Ïò§Î•∏Ï™Ω Ï†ïÎ†¨) */}
      <div className="flex justify-end items-center">
        <div className="flex space-x-2">
          <button
            onClick={() => setSortBy('latest')}
            className={`px-3 py-1 rounded ${sortBy === 'latest' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}`}
          >
            ÏµúÏã†Ïàú
          </button>
          <button
            onClick={() => setSortBy('rating')}
            className={`px-3 py-1 rounded ${sortBy === 'rating' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}`}
          >
            ÌèâÏ†êÏàú
          </button>
        </div>
      </div>

      {/* Î°úÍ∑∏Ïù∏ ÌïÑÏöî Î©îÏãúÏßÄ */}
      {showLoginRequired && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 text-yellow-800">
          Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.
        </div>
      )}

      {/* Î¶¨Î∑∞ Î™©Î°ù */}
      <div className="space-y-4">
        {reviews.map((review) => (
          <div key={review.id} className="border border-gray-200 rounded-lg">
            {editingReview?.id === review.id ? (
              // ÏàòÏ†ï Î™®Îìú
              <div className="p-4">
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">ÌèâÏ†ê</label>
                    <div className="flex space-x-1">
                      {[1, 2, 3, 4, 5].map((star) => (
                        <button
                          key={star}
                          onClick={() => setEditingReview(prev => prev ? { ...prev, rating: star } : null)}
                          className={`text-2xl ${editingReview.rating >= star ? 'text-yellow-500' : 'text-gray-300'}`}
                        >
                          ‚òÖ
                        </button>
                      ))}
                    </div>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">ÎÇ¥Ïö©</label>
                    <textarea
                      value={editingReview.content}
                      onChange={(e) => setEditingReview(prev => prev ? { ...prev, content: e.target.value } : null)}
                      className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                      rows={4}
                    />
                  </div>
                  <div className="flex justify-end space-x-2">
                    <button
                      onClick={() => setEditingReview(null)}
                      className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors"
                    >
                      Ï∑®ÏÜå
                    </button>
                    <button
                      onClick={handleUpdateReview}
                      className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
                    >
                      ÏàòÏ†ï
                    </button>
                  </div>
                </div>
              </div>
            ) : (
              // ÌëúÏãú Î™®Îìú
              <div className="p-4">
                <div className="flex justify-between items-start mb-1">
                  <div className="flex items-center space-x-2">
                    {/* ÏÇ¨Ïö©Ïûê ÏïÑÎ∞îÌÉÄ (Ïù¥ÎØ∏ÏßÄ Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ Ïù¥ÎãàÏÖú) */}
                    {review.userProfileImage ? (
                      <img src={review.userProfileImage} alt={review.userName} className="w-8 h-8 rounded-full object-cover" />
                    ) : (
                      <div className="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center text-xs text-white">
                        {review.userName?.[0] || '?'}
                      </div>
                    )}
                    <div className="flex items-center gap-1.5">
                      {[1, 2, 3, 4, 5].map((star) => {
                        const isMine = !!(currentUser && review.userName === (currentUser as any).username);
                        const scoreVal = isMine && typeof myRating === 'number' && myRating > 0 ? myRating as number : (Number(review.rating) || 0);
                        const filled = scoreVal >= star ? 1 : Math.max(0, Math.min(1, scoreVal - (star - 1)));
                        return <Star key={star} value={filled} size={18} color="#8B5CF6" emptyColor="#E5E7EB" />;
                      })}
                    </div>
                    <span className="text-sm font-semibold text-gray-800">{
                      (() => {
                        const isMine = !!(currentUser && review.userName === (currentUser as any).username);
                        const scoreVal = isMine && typeof myRating === 'number' && myRating > 0 ? myRating as number : (Number(review.rating) || 0);
                        return scoreVal.toFixed(1);
                      })()
                    }</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <span className="text-xs text-gray-500 mr-2">{review.createdAt ? (new Date(review.createdAt).toLocaleDateString()) : ''}{review.updatedAt && review.updatedAt !== review.createdAt ? ' (ÏàòÏ†ïÎê®)' : ''}</span>
                    <span className="font-semibold text-gray-800">{review.userName}</span>
                    <button
                      onClick={() => handleToggleLike(review.id)}
                      className={`flex items-center space-x-1 px-2 py-1 rounded text-sm transition-colors ${
                        review.isLikedByCurrentUser
                          ? 'bg-blue-100 text-blue-600 hover:bg-blue-200'
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`}
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4">
                        <path d="M2 10h4v12H2zM22 10c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L13 1 6.59 7.41C6.22 7.78 6 8.3 6 8.83V20c0 1.1.9 2 2 2h8c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73V10z"/>
                      </svg>
                      <span>{review.likeCount}</span>
                    </button>
                    {currentUser && review.userName === (currentUser as any).username && (
                      <>
                        <button
                          onClick={() => setEditingReview(review)}
                          className="px-2 py-1 bg-blue-100 text-blue-600 rounded text-sm hover:bg-blue-200 transition-colors"
                        >
                          ÏàòÏ†ï
                        </button>
                        <button
                          onClick={() => handleDeleteReview(review.id)}
                          className="px-2 py-1 bg-red-100 text-red-600 rounded text-sm hover:bg-red-200 transition-colors"
                        >
                          ÏÇ≠Ï†ú
                        </button>
                      </>
                    )}
                  </div>
                </div>
                
                <div className="text-gray-700">
                  {expandedReviews.has(review.id) ? (
                    <div>
                      <p className="whitespace-pre-wrap">{review.content}</p>
                      <button
                        onClick={() => toggleReviewExpansion(review.id)}
                        className="text-purple-600 hover:text-purple-800 text-sm mt-2"
                      >
                        Ï†ëÍ∏∞
                      </button>
                    </div>
                  ) : (
                    <div>
                      <p className="line-clamp-3">{review.content}</p>
                      {review.content.length > 150 && (
                        <button
                          onClick={() => toggleReviewExpansion(review.id)}
                          className="text-purple-600 hover:text-purple-800 text-sm mt-2"
                        >
                          ÎçîÎ≥¥Í∏∞
                        </button>
                      )}
                    </div>
                  )}
                </div>
                
                <CommentList reviewId={review.id} myRating={myRating ?? 0} />
              </div>
            )}
          </div>
        ))}
      </div>

      {reviews.length === 0 && (
        <div className="text-center py-12 text-gray-500">
          ÏïÑÏßÅ Î¶¨Î∑∞Í∞Ä ÏóÜÏäµÎãàÎã§. Ï≤´ Î≤àÏß∏ Î¶¨Î∑∞Î•º ÏûëÏÑ±Ìï¥Î≥¥ÏÑ∏Ïöî!
        </div>
      )}
    </div>
  );
}
